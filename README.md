# ASU Spec2Tapeout ICLAD 2025 Hackathon Problems


## Infrastructure setup

### SLM category: 
The prerequisites are iVerilog and OpenROAD-flow-scripts that should be available on your laptops. For SLM problems, you will not be evaluated on hidden testcases!

### LLM category:
Solving these problems requires the Docker image already available in your GCP VM instance. You can run the docker image as follows to create an environment that has OpenROAD-flow-scripts and iVerilog already installed:

```
docker run -it --rm \
  -v ~/iclad_hackathon:/workspace/iclad_hackathon \
  iclad_hackathon:latest bash
```

Inside the docker container, you will find this repository already cloned and available to you in 

```
/workspace/iclad_hackathon/ICLAD-Hackathon-2025/problem-categories
```

## Directory Structure

```plaintext
ASU‑Spec2Tapeout‑ICLAD25‑Hackathon/
├── README.md
├── example_problem/
│   ├── p1.json
│   ├── intermediate/
|       └── Intermediate files needed to get to the output 
│   ├── ouput/
│       └── Required outputs to be generated. 
│           - Reference RTL and constraint files
│           - Example final ODBs
│
├── problems/
│   └── visible 
│       └── *.yaml files. Visible input specifications for each challenge problem.
│           These are the primary inputs your LLM agent will consume to generate RTL and physical design outputs.
│           Each YAML file typically includes clock, module interface, and expected behavior.
│
├── solutions/
|   ├── your_agent.py
|       └── This is the script that you use to generated the output solutions. Its the script that interacts with the
|           language model
│   ├── visible/
│       ├── p1/
│       ├── p5/
│           └── This is where you submit your full solution for each problem.
│               Include:
│               - RTL generated by your LLM agent
│               - SDC constraints
│               - Final odb files (e.g., `.def`, `.odb`)
│  
├── evaluation/
│   ├── evalaute_openroad.py
|       └──  script that inputs odb file and sdc file and ORFS home directory to generate the metrics needed using report_metrics.tcl. Calls OpenROAD under the hood. 
|   ├── evalaute_verilog.py
|       └──  This uses input verilog and testbench to check functionality. Call iVerilog under the hood. 
│   ├── report_metrics.tcl 
│   └── visible
│       └── This directory contains testbenches and reference json files to needed to evaluate your generated solution for |            each problem


```

## Problem Set

Your objective is to design tapeout-ready ASICs based on the given problem specifications in the yaml format described below. For each problem, you must develop an LLM agent script/tool that produces the following output files:

## Required Outputs

- Synthesizable RTL in SystemVerilog  
- Constraint files in SDC format  
- Tapeout-ready OpenROAD DB (ODB), i.e., 6_final.odb generated by ORFS

## Guidelines

- Module signatures are provided for each problem. Your generated RTL must **strictly follow** these signatures to ensure compatibility with automated test frameworks.  
- Your LLM agent script/tool should **generalize to unseen/hidden problems**, which will be provided in a similar format.  
- Please provide solutions for **all** the questions, even if your script does not generalize to other testcases.  

## Hints

- You have access to **iVerilog**. Use it iteratively with your LLM to verify the functional correctness of your code.  
- Once your RTL is verified, use **OpenROAD-flow-scripts** to generate the tapeout-ready database and other physical design files and reports.  
- You can use LLMs to learn how to work with ORFS and use the LLM to write a script to integrate your design into the existing ORFS framework.  
- The provided constraints or specifications of frequency are relatively relaxed and should be met without requiring multiple iterations of physical design.  

---

## Submission guidelines

Solutions to problems must be present in the folder solution folder. The top level must include your agent script to generate solutions for hidden testcases and a README with instructions on how to run the script.  The rest of the solutions should be present in their respective problem folders as described below: 
```
├── solutions/
|   ├── your_agent.py
|       └── This is the script that you use to generated the output solutions. Its the script that interacts with the
|           language model
│   ├── visible/
│       ├── p1/
│       ├── p5/
│           └── This is where you submit your full solution for each problem.
│               Include:
│               - RTL generated by your LLM agent
│               - SDC constraints
│               - Final odb files (`6_final.odb`)
```


You can also upload this entire repository with your solutions and agent script to a forked version of this repository on your own GH account. You can also leave the solutions in the VM and provide us a path in the VM for evaluation. Once you are done with the problems. Please email us the path to the VM created for you, so we can locate the repository with the solutions. 

## Evaluation setup

For each problem you must run two evaluations scripts

### 1. Functional evaluation of Verilog

This will check the correctness of your generated RTL using the provided testbenches and iVerilog. An example command is provided below

```
python3 evaluate_verilog.py --verilog ../example_problem/output/iclad_seq_detector.v --problem 1 --tb ../example_problem/intermediate/iclad_seq_detector_tb.v
```

### 2. Physical evaluation of layout metrics

This will check the metrics of your generated layouts using the specification jsons provided. An example command is provided below

```
python3 evaluate_openroad.py --odb ../solutions/visible/p1/6_final.odb --sdc ../solutions/visible/p1/6_final.sdc --flow_root ../../OpenROAD-flow-scripts --problem 1
```

## Example: YAML Spect for Sequence Detector Design for `0011`

```yaml
seq_detector_0011:
  description: Detects a binary sequence "0011" in the input stream.
  tech_node: SkyWater 130HD
  clock_period: 1.1ns
  ports:
    - name: clk
      direction: input
      type: logic
      description: Clock input
    - name: reset
      direction: input
      type: logic
      description: Synchronous reset (active high)
    - name: data_in
      direction: input
      type: logic
      description: Serial data input
    - name: detected
      direction: output
      type: logic
      description: Asserted high for one cycle when '0011' is detected.
  module_signature: |
    module seq_detector_0011(
        input clk,
        input reset,
        input data_in,
        output reg detected
    );
  sequence_to_detect: '0011'
  sample_input: '0001100110110010'
  sample_output: '0000010001000000'

```


